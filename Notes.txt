* Typescript Notes *

**** SECTION 1 : GETTING STARTED  **** **** **** **** **** **** 
* What is Typescript ?
-> A Javascript Superset : A language building up on Javascript
-> Adds new features + Advantages to Javascript
-> Browser CAN'T execute it!
-> TS -CompiledTo--> JS
-> Features are compiled to JS "workarounds", possible errors are thrown

* Why Typescript ?
function add(num1, num2) {
    return num1 + num2;
}

console.log(add("2","3"));
--> Unwanted Behavior at Runtime -> Mitigation Strategies : Add if check to add function Validate & sanitize user input
--> Developers can still write invalid code -> TS is a "Tool" that helps developers write better code!


* Installing & Using TypeScript
npm install -g typescript

-> create "using-ts.ts" file
-> copy that code and make some changes add types
var button = document.querySelector("button")!;
var input1 = document.getElementById("num1")! HTMLInputElement;
var input2 = document.getElementById("num2")! HTMLInputElement;
function add(num1: number, num2: number) {
    return num1 + num2;
}
button.addEventListener("click", function () {
    console.log(add(+input1.value, +input2.value));
});

* TypeScript Overview 
-> TS adds "Types!"
-> Next-gen JS Features (compiled down for older Browsers)
-> Non-JS Features like Interface or Generics
-> Meta-Programming Features like Decorators
-> Rich Configuration Options
-> Modern Tooling that helps even in non-TypeScript Projects

**** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** **** ****

**** SECTION 2 : TYPESCRIPT BASICS & BASIC TYPES  **** **** **** **** **** ****
* Core Types *
-> number : 1, 5.3, -10 
-> string "Hi", 'Hi' : All text values
-> boolean : true, false : just these two, no "truthy" or "falsy" values

function add(n1: number, n2: number) {
    return n1 + n2;
}

const number1 = '5';
const number2 = 2.8;

const result = add(number1, number2);
console.log(result);

-> TypeScript's type system only helps you during development
(before the code gets compiled)

* Typescript Types vs Javascript Types
-> The key differences is: Javascript uses "dynamic types"(resolved at runtime)
-> TypeScript uses "static types" (set during development)

* Working with Numbers, Strings & Booleans
function add(n1: number, n2: number, showResult: boolean, phase: string) {
    const result = n1 + n2;
    if(showResult) {
        console.log(phase + result);
    }else {
        return result;
    } 
}

const number1 = 5;
const number2 = 2.8;
const printResult = true;
const resultPhase = 'Result it : ';

add(number1, number2, printResult, resultPhase);


* Type Assignment & Type Inference
let number1: number;
number1 = 5;
const number2 = 2.8;

// Incorrect
let resultPhase = 'Result it : ';
resultPhase = 0;

* Core Types *
-> object : {age: 30} Any JavaScript object, more specific types are possible
const person: {
    name: string;
    age: number;
} = {
    name: "Vedat",
    age: 21
}

* Core Types *
-> Array: [1,2,3] Any JavaScript array, type can be flexible or strict (regarding the element type)
const person = {
    name: "Vedat",
    age: 21,
    hobbies: ['Sports', 'Cooking']
}

let favouriteActivities: string[];
favouriteActivities = ['Sports', 2]; // Error

for(const hobby of person.hobbies) {
    console.log(hobby.toUpperCase());
    console.log(hobby.map()); // Error
}

* Core Types *
-> Tuple: [1,2] Fixed-length array where the type of the elements is known, but need not be the same
const person: {
    name: string;
    age: number;
    hobbies: string[];
    role: [number, string];
} = {
    name: "Vedat",
    age: 21,
    hobbies: ['Sports', 'Cooking'],
    role: [2, 'author']
}

person.role.push('admin'); // Error
person.role[1] = 10; // Error

-> Tuple is not flexible as Array, it is fixed length and fixed type

* Core Types *
-> Enum: enum {NEW, OLD} Enum : Automatically enumerated global constant identifiers
const enum Role {
    ADMIN = 6,
    READ_ONLY,
    AUTHOR = 'AUTHOR'
}

const person = {
    name: "Vedat",
    age: 21,
    hobbies: ['Sports', 'Cooking'],
    role: Role.ADMIN
}

if(person.role === Role.ADMIN) {
    console.log('is admin');
}

* Core Types *
-> Any: * Avoid using "any" because it disables TS's powerful checks
-> Use it when you don't know the type of the value
-> Any is turning off TS checks and go back to JS world

* Core Types *
-> Union: Combine multiple types
-> You can be more flexible regarding the types of the values you're working with
-> Use it when you don't know the type of the value

function combine(input1: (number | string), input2: (number | string)) {
    let result;

    if(typeof input1 === 'number' && typeof input2 === 'number') {
        const result = input1 + input2;
        return result;
    }else {
        result = input1.toString() + input2.toString();
    }

    return result;
}

const combinedAges = combine(30, 26);
console.log(combinedAges);

const combinedNames = combine("Max", "Anna");
console.log(combinedNames);


* Core Types *
-> Literal Types: Combine types with specific values
-> Use it when you want to restrict the values to a specific set of values

function combine(
    input1: (number | string),
    input2: (number | string),
    resultConversion: 'as-text' | 'as-number'
) {
    let result;

    if(typeof input1 === 'number' && typeof input2 === 'number' || resultConversion === 'as-number') {
        const result = +input1 + +input2;
        return result;
    }else {
        result = input1.toString() + input2.toString();
    }
    return result;

    /*if(resultConversion === 'as-number') {
        return +result;
    }else {
        return result.toString();
    }*/
}

const combinedAges = combine(30, 26, 'as-number');
console.log(combinedAges);

const combinedStringAges = combine('30', '26', 'as-number');
console.log(combinedStringAges);

const combinedNames = combine("Max", "Anna", 'as-text');
console.log(combinedNames);

* Core Types *
-> Aliases: Create your own types
-> Use it when you want to use a type more than once and you want to give it a more descriptive name

type Combinable = number | string;
type ConversionDescriptor = 'as-number' | 'as-text';

function combine(
    input1: Combinable,
    input2: Combinable,
    resultConversion: ConversionDescriptor
) {

* Core Types *
-> Functions & Function Types
-> void is a valid type in TS
-> Use it when you don't want to return anything from a function
--> undefined is same as void but it expects a return value

function add(n1: number, n2: number): number {
    return n1 + n2;
}

function printResult(num: number): void {
    console.log('Result: ' + num);
}

printResult(add(5, 12));

* Functions as Types *
function add(n1: number, n2: number): number  {
    return n1 + n2;
}

function printResult(num: number): void {
    console.log('Result: ' + num);
}

printResult(add(5, 12));

//let combineValues: Function;
//let combineValues: () => number;
let combineValues: (a: number, b: number) => number;
combineValues = add;
//combineValues = 5; --> Error
//combineValues = printResult; --> Error

console.log(combineValues(8, 8));


//let someValue: undefined;

// console.log(printResult(add(5, 12))); --> undefined

* Function Types & Callbacks *
function addAndHandle(n1: number, n2: number, cb: (num: number) => void) {
    const result = n1 + n2;
    cb(result);
}

addAndHandle(10, 20, (result) => {
    console.log(result);
});

* Unknown & Never *
-> Unknown: Better than any | Use it when you don't know the type of the value | It is more restrictive than any
-> Never: Use it when you never expect a function to return anything

** My Own Questions **
- What is Callback Function ?
-> In TS, a callback function is simple a function that is passed as an argument to another function and
is intended to be called at a later time.
-> Usally after some asynchronous operation completed or under certain conditions.
-> Callback functions are commonly used in scenerios like event handling, async programming, and functional programming

Basic example:

function process(callback: () => void) {
    console.log('Processing...');
    setTimeout(() => {
        callback();
    }, 2000);
}

function callbackFunction() {
    console.log('Callback function called!');
}

process(callbackFunction);

************************************************************************************************************

**** SECTION 3 : COMPILING & CONFIGURING TYPESCRIPT **** **** **** **** **** ****
* Using Watch Mode
> tsc app.ts -w

* Compiling the Entire Project & Multiple Files
> tsc --init
- It creates a tsconfig.json file
- It is a configuration file for the TypeScript compiler
- It allows you to configure the compiler and the compilation process
- It is a JSON file
-> now you use tsc -w for compiling all files
> tsc

* Including & Excluding Files
-> You can specify which files should be included or excluded from the compilation process
-> You can use the "files" property to specify the files to be included
-> You can use the "exclude" property to specify the files to be excluded
-> Open tsconfig.json file and add the following code
{
    ....
    "include": ["app.ts"],
    "exclude": ["node_modules", "analytics.ts"]
}
-> From now on, only app.ts will be compiled and analytics.ts will be excluded
> tsc
-> Now, only app.ts will be compiled
-> If you dont want to add all files ends with .dev.ts
-> You can use "exclude" property like this
{
    ....
    "exclude": ["*.dev.ts"]
}
-> If you dont want to exclude all files ends with .dev.ts in the subfolders
-> You can use "exclude" property like this
{
    ....
    "exclude": ["**/*.dev.ts"]
}

-> For including all files in the subfolders
{
    ....
    "include": ["src/**/*.ts"]
}

* Setting up a Compilation Target
-> You can specify the ECMAScript version you want to target
-> You can use the "target" property to specify the ECMAScript version
-> const is not supported in ES5
-> Open tsconfig.json file and add the following code
{
    ....
    "target": "es5",
}
-> Target is the version of ECMAScript you want to compile your code to

{
    ....
    "target": "es6",
}

* Understanding Core TypeScript Libs
-> You can specify the core TypeScript libraries you want to include
-> You can use the "lib" property to specify the core TypeScript libraries
-> Open tsconfig.json file and add the following code
{
    ....
    "lib": ["DOM", "ES6", "DOM.Iterable", "ScriptHost"]
}
-> The "lib" property is used to specify the core TypeScript libraries you want to include
-> The "DOM" library is used to include the DOM library
-> The "ES6" library is used to include the ES6 library
-> The "DOM.Iterable" library is used to include the DOM.Iterable library
-> The "ScriptHost" library is used to include the ScriptHost library
-> Default "lib" property contains a lot of libraries like Map, Set, Promise, etc.

* More Configuration & Compilation Options
-> jsx : Specify the JSX code generation
-> declaration : Generate corresponding .d.ts files

* Working with Source Maps
-> If we want to see the original TypeScript code in the browser we can use source maps true
-> You can use the "sourceMap" property to generate source maps
-> Open tsconfig.json file and add the following code
{
    ....
    "sourceMap": true
}

* rootDir and outDir
-> outDir is the directory where the compiled files will be placed
-> rootDir is the directory where the TypeScript files are located
-> You can use "src" and "dist" folders where src will be rootDir and dist will be outDir
-> Open tsconfig.json file and add the following code
{
    ....
    "rootDir": "src",
    "outDir": "dist"
}

* Stop Emitting Files on Compilation Errors
"noEmitOnError": false,
-> If there is compilation errors, when you compile that file it will emit the file
-> But if its true, it will not emit the file to the dist folder


**** SECTION 4: TypeScript & Modern Javascript  **** **** **** **** **** ****
* let and const
-> let is not accessible outside of the block scope
-> var is accessible outside of the block scope

* Arrow Function
const add = (a: number, b: number): number => a + b;

const printOutput: (a: number | string) => void = output => console.log(output);

const button = document.querySelector('button');

if(button) {
    button.addEventListener('click', event => console.log(event));
}

//console.log(add(2, 5));
printOutput(add(2, 5));


* Default Function Parameters
-> Default function parameters must be end of the list like a cannot have default parameter
const add = (a: number, b: number = 1): number => a + b;

....

printOutput(add(5));


* The Spread Operator (...)
onst activeHobbies = ['Hiking'];

activeHobbies.push(...hobbies);

console.log(activeHobbies);


const person = {
    name: "Vedat",
    age: 22
};

const copiedPerson = {...person};

console.log(copiedPerson);


* Rest Parameters
// add function parameters will be number array but we dont know the size
const add = (...numbers: number[]) => {
    
    return numbers.reduce((curResult, curValue) => {
        return curResult + curValue;
    }, 0);
    
}

const addedNumbers = add(5, 10, 2);

console.log(addedNumbers);


// If we will get 3 number, we could use "Tuple"
const add = (...number: [number, number, number]) => {
    ...
}

const addedNumbers = add(5, 10, 2);

...

* Array & Object Destructuring
const hobbies = ['Sports', 'Hiking'];
const person = {
    fName: "vedat",
    age: 22
}


const hobby1 = hobbies[0];
const hobby2 = hobbies[1];

or 

const [hobby1, hobby2, ...remaniningHobbies] = hobbies;

console.log(hobbies, hobby1, hobby2)


const {fName: userName, age} = person;

console.log(fName: userName, age, person);



* How Code Gets Compiled * Wrap Up






























